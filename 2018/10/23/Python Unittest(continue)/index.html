<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="My personal blog">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="Baobiy" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        Python unittest(持续记录)｜undefined
        
    </title>

    <link rel="canonical" href="http://yoursite.com/2018/10/23/Python Unittest(continue)/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Baobiy
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img" src="">


<style>
    
    header.intro-header {
        background-image: url('');
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>Python unittest(持续记录)</h1>
                    
                    <h2 class="subheading">Python Unittest</h2>
                    
                    <span class="meta">
                         作者 Baobiy
                        <span>
                          日期 2018-10-23
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#Python"
                           title="Python">Python</a>
                        
                        <a class="tag" href="/tags/#unittest"
                           title="unittest">unittest</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            Python unittest(持续记录)
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h1 id="selenium-IDE"><a href="#selenium-IDE" class="headerlink" title="selenium IDE"></a>selenium IDE</h1><p>selenium IDE是嵌入到firefox中的一个插件，本文使用 Firefox54.0.1 (64 位)，<br>selenium IDE2.9.1，最新版firefox中安装selenium IDE后，缺少很多功能（比如文件导出为不同格式) 因此更倾向于使用 2.9.1.</p>
<h2 id="selenium-IDE的安装-及介绍"><a href="#selenium-IDE的安装-及介绍" class="headerlink" title="selenium IDE的安装 及介绍"></a>selenium IDE的安装 及介绍</h2><p>通过firefox 浏览器访问selenium 下载页面：<a href="http://docs.seleniumhq.org/download/" target="_blank" rel="noopener">http://docs.seleniumhq.org/download/</a></p>
<p>或通过网页搜索：selenium_ide-2.9.1-fx.xpi，直接下载后拖拽进浏览器，会弹出是否需要安装的提示框，点击安装，重启浏览器即可。</p>
<p>安装后在工具中寻找。</p>
<p><img src="https://i.imgur.com/2YBrnwd.png" alt=""></p>
<p>各个部分介绍：</p>
<pre><code>1---文件(File)：创建、打开和保存测试案例和测试案例集。
编辑(Edit)：复制、粘贴、删除、撤销和选择测试案例中的所有命令。
Options (设置): 用于设置seleniunm IDE。
2---用来填写被测网站的地址。
3---速度控制：控制案例的运行速度。
4---运行所有：运行一个测试案例集中的所有案例。
5---运行：运行当前选定的测试案例。
6---暂停/恢复：暂停和恢复测试案例执行。
7---|单步：可以运行一个案例中的一行命令。
8---录制：点击之后，开始记录你对浏览器的操作。
9---案例集列表。
10---测试脚本；table 标签：用表格形式展现命令及参数。source 标签：用原始方式展现，默
认是HTML 语言格式，也可以用其他语言展示。
11---查看脚本运行通过/失败的个数。
12---当选中前命令对应参数。
13---日志/参考/UI 元素/Rollup
日志：当你运行测试时，错误和信息将会自定显示。
参考：当在表格中输入和编辑selenese 命令时，面板中会显示对应的参考文档。
UI 元素/Rollup：参考帮助菜单中的，UI-Element Documentation。
</code></pre><h2 id="Selenium-IDE-脚本录制"><a href="#Selenium-IDE-脚本录制" class="headerlink" title="Selenium IDE 脚本录制"></a>Selenium IDE 脚本录制</h2><p>打开selenium IDE 录制按钮默认为启动状态， 在地址栏中输入要录制的URL （ 如，<br><a href="http://www.baidu.com）,脚本录制完成，关闭录制按钮。" target="_blank" rel="noopener">http://www.baidu.com）,脚本录制完成，关闭录制按钮。</a></p>
<p>selenium IDE 为我们录制的脚本不是100%符合我们的需求的，所以，编辑录制的脚本是必不可少<br>的工作。</p>
<p>1 编辑一行命令或注释。</p>
<p>在Table 标签下选中某一行命令，命令由command、Target、value 三部分组成。可以对这三部分<br>内容那进行编辑。</p>
<p><img src="https://i.imgur.com/gls8oOQ.png" alt=""></p>
<p>2 插入命令</p>
<p>在某一条命令上右击，选择“insert new command”命令，就可以插入一个空白，然后对空白<br>行进程编辑。</p>
<p><img src="https://i.imgur.com/mCMc9Uj.png" alt=""></p>
<p>3 插入注解</p>
<p>以上面同样的方式右击选择“insert new comment”命令插入注解空白行，本行内容不被执行，可<br>以帮助我们更好的理解脚本，插入的内容以紫色字体显示。</p>
<p><img src="https://i.imgur.com/4hiyjXR.png" alt=""></p>
<p>4 移动命令或注解</p>
<p>有时我们需要移动某行命令的顺序，我们只需要左击鼠标拖动到相应的位置即可。</p>
<p><img src="https://i.imgur.com/RK5Oxdp.png" alt=""></p>
<p>5 定位辅助</p>
<p>当selenium IDE 录制脚本时，它会存储额外的信息，支持用户挑选其他格式的定位器来代替默认格<br>式的定位器，这种特殊性对于学习定位器很有用。<br><img src="https://i.imgur.com/JqyD1Gn.png" alt=""></p>
<p>我们可以选择其他的命令来代替“name=btnG” 命令，当然，脚本依然是可以运行的。</p>
<p>关于selenium IDE 的更多使用技巧不在不是本书的讨论重点，请读者参考其资料进行学习。</p>
<h1 id="引入-unittest-框架"><a href="#引入-unittest-框架" class="headerlink" title="引入 unittest 框架"></a>引入 unittest 框架</h1><p>通过seleinium IDE 完成脚本的录制之后，可以将其导出为加了python unittest 单元测试框架的相应脚本。</p>
<p><img src="https://i.imgur.com/VomiVMk.png" alt=""></p>
<p>将脚本导出，保存为baidu.py ，通过python IDLE 编辑器打开。</p>
<pre><code>    # -*- coding: utf-8 -*-
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select
from selenium.common.exceptions import NoSuchElementException
from selenium.common.exceptions import NoAlertPresentException
import unittest, time, re

class Baidu(unittest.TestCase):
    def setUp(self):
        self.driver = webdriver.Firefox()
        self.driver.implicitly_wait(30)
        self.base_url = &quot;https://www.baidu.com/&quot;
        self.verificationErrors = []
        self.accept_next_alert = True

    def test_baidu(self):
        driver = self.driver
        driver.get(self.base_url + &quot;/&quot;)
        driver.find_element_by_id(&quot;kw&quot;).click()
        driver.find_element_by_id(&quot;kw&quot;).clear()
        driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;test&quot;)
        driver.find_element_by_id(&quot;su&quot;).click()
        driver.find_element_by_link_text(u&quot;test_百度翻译&quot;).click()

    def is_element_present(self, how, what):
        try: self.driver.find_element(by=how, value=what)
        except NoSuchElementException as e: return False
        return True

    def is_alert_present(self):
        try: self.driver.switch_to_alert()
        except NoAlertPresentException as e: return False
        return True

    def close_alert_and_get_its_text(self):
        try:
            alert = self.driver.switch_to_alert()
            alert_text = alert.text
            if self.accept_next_alert:
                alert.accept()
            else:
                alert.dismiss()
            return alert_text
        finally: self.accept_next_alert = True

    def tearDown(self):
        self.driver.quit()
        self.assertEqual([], self.verificationErrors)

if __name__ == &quot;__main__&quot;:
    unittest.main()
</code></pre><p>#引入方法分析</p>
<pre><code>import unittest
</code></pre><p>首先要引入unittest框架包</p>
<pre><code>class Baidu(unittest.TestCase):
</code></pre><p>Baidu类继承unittest.TestCase 类，从TestCase类继承是告诉unittest模块的方式，这是一个测试案例。</p>
<pre><code>def setUp(self):
    self.driver = webdriver.Firefox()
    self.base_url = &quot;http://www.baidu.com/&quot;**
</code></pre><p>setUp 用于设置初始化的部分，在测试用例执行前，这个方法中的函数将先被调用。这里将浏览器的调用和URL 的访问放到初始化部分。</p>
<pre><code>self.verificationErrors = []
</code></pre><p>脚本运行时，错误的信息将被打印到这个列表中。</p>
<pre><code>self.accept_next_alert = True
</code></pre><p>是否继续接受下一个警告。</p>
<pre><code>def test_baidu(self):
    driver = self.driver
    driver.get(self.base_url + &quot;/&quot;)
    driver.find_element_by_id(&quot;kw&quot;).click()
    driver.find_element_by_id(&quot;kw&quot;).clear()
    driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;test&quot;)
    driver.find_element_by_id(&quot;su&quot;).click()
</code></pre><p>test_baidu 中放置的就是我们的测试脚本了，这部分我们并不陌生；因为我们执行的脚本就在这里。</p>
<pre><code>def is_element_present(self, how, what):
    try: self.driver.find_element(by=how, value=what)
    except NoSuchElementException as e: return False
    return True
</code></pre><p><code>is_element_present</code> 函数用来查找页面元素是否存在， try…except…. 为python 语言的异常捕捉。</p>
<p><code>is_element_present</code> 函数在这里用处不大，通常删除，因为判断页面元素是否存在一般都加在testcase 中。</p>
<pre><code>def is_alert_present(self):
    try: self.driver.switch_to_alert()
    except NoAlertPresentException as e: return False
    return True
</code></pre><p>对弹窗异常的处理</p>
<pre><code>def close_alert_and_get_its_text(self):
    try:
        alert = self.driver.switch_to_alert()
        alert_text = alert.text
        if self.accept_next_alert:
            alert.accept()
        else:
            alert.dismiss()
        return alert_text
    finally: self.accept_next_alert = True
</code></pre><p>关闭警告以及对得到文本框的处理，if 判断语句前面已经多次使用，并不陌生；try….finally…为python的异常处理。</p>
<pre><code>def tearDown(self):
    self.driver.quit()
    self.assertEqual([], self.verificationErrors)
</code></pre><p>这个是难点，对前面verificationErrors 方法获得的列表进行比较；如查verificationErrors 的列表不为空，输出列表中的报错信息。</p>
<pre><code>if __name__ == &quot;__main__&quot;:
    unittest.main()
</code></pre><p>unitest.main()函数用来测试类中以test 开头的测试用例</p>
<p>这样一一分析下来，我们对unittest 框架有了初步的了解。运行脚本，因为引入了unittest 框架，<br>所以控制台输出了用例的执行个数、时间以及是否OK 等信息。</p>
<p><img src="https://i.imgur.com/bJXXIwg.png" alt=""></p>
<h1 id="Unittest-单元测试框架解析"><a href="#Unittest-单元测试框架解析" class="headerlink" title="Unittest 单元测试框架解析"></a>Unittest 单元测试框架解析</h1><p>widget.py（被测试类）</p>
<pre><code>    #coding=utf-8

class Widget:
    def __init__(self, size=(40, 40)):
        self._size = size

    def getSize(self):
        return self._size

    def resize(self, width, height):
        if width &lt; 0 or height &lt; 0:
            raise (ValueError, &quot;illegal size&quot;)
        self._size = (width, height)

    def dispose(self):
        pass
</code></pre><p>auto.py（测试类）</p>
<pre><code>#coding = utf-8

from widget import Widget
import unittest

class WidgetTestCase(unittest.TestCase):
    def setUp(self):
        self.widget = Widget()

    def testSize(self):
        self.assertEqual(self.widget.getSize(),(40, 40))

    def testResize(self):
        self.widget.resize(100, 100)
        self.assertEqual(self.widget.getSize(),(100, 100))

    def tearDown(self):
        self.widget.dispose()
        self.widget = None

def suite():
    suite = unittest.TestSuite()
    suite.addTest(WidgetTestCase(&quot;testSize&quot;))
    suite.addTest(WidgetTestCase(&quot;testResize&quot;))
    return suite
    #return unittest.makeSuite(WidgetTestCase, &quot;test&quot;)

if __name__ == &apos;__main__&apos;:
    #suite = suite()

    #runner = unittest.TextTestRunner()
    #runner.run(suite)
    #unittest.main(defaultTest=&apos;suite&apos;)
    unittest.main()
</code></pre><p>1、 用import语句引入unittest模块</p>
<p>2、 让所有执行测试的类都继承于TestCase类，可以将TestCase看成是对特定类进行测试的方法的集合</p>
<p>3、 SetUp()方法中进行测试前的初始化工作，tearDown（）方法中执行测试后的清除工作（资源释放）。SetUp（）和tearDown（）都是TestCase类中定义的方法</p>
<pre><code>setUp() + tearDown() ：在每个测试方法执行前以及执行后执行一次，setUp用来为测试准备环境，tearDown用来清理环境，准备之后的测试
setUpClass() 与 tearDownClass()：在所有case执行之前准备一次环境，并在所有case执行结束之后再清理环境    
</code></pre><p>4、 在testSize（）中调用assertEqual（）方法，对Widget类中getSize（）方法的返回值和预期值进行比较，确保两者是相等的，assertEqual（）也是TestCase类中定义的方法。可以对widget.py多方法测试（如：再加入一个testResize（）来对size进行重新赋值）</p>
<p>5、 提供名为suite（）的全局方法，PyUnit在执行测试的过程调用suit（）方法来确定有多少个测试用例需要被执行，可以将TestSuite看成是包含所有测试用例的一个容器。</p>
<pre><code>test suite（测试套件）的作用是批量运行多个测试用例，此外还可以做的操作是：
    调整测试用例执行顺序
    多个test suite中的test case执行
</code></pre><p>6、 完整的单元测试很少只执行一个测试用例，通常都需要编写多个测试用例来对某一个软件功能进行比较完整的测试，这些相关的测试用例称为一个测试用例集（即PyUnit中的TestSuite类）。suite（）作为整个单元测试的入口，PyUnit通过调用它来完成整个测试过程。</p>
<p>7、 如果用于测试的类中所有测试方法都以test开头，甚至可以用PyUnit模块提供的makeSuite（）方法来构造一个：</p>
<pre><code>def suite():
    return unittest.makeSuite(WidgetTestCase, &quot;test&quot;)
</code></pre><p>8、 PyUnit 使用TestRunner 类作为测试用例的基本执行环境，来驱动整个单元测试过程。在进行单元测试时一般不直接使用TestRunner 类，而是使用其子类TextTestRunner 来完成测试，并将测试结果以文本方式显示出来：</p>
<pre><code>runner = unittest.TextTestRunner()
runner.run(suite)
</code></pre><p>TextTestRunner（）：</p>
<pre><code>&gt;&gt;&gt; help(unittest.TextTestRunner)
Help on class TextTestRunner in module unittest.runner:

class TextTestRunner(builtins.object)
|  A test runner class that displays results in textual form.
|  
|  It prints out the names of tests as they are run, errors as they
|  occur, and a summary of the results at the end of the test run.
Methods defined here:
|  
|  __init__(self, stream=None, descriptions=True, verbosity=1, failfast=False, buffer=False, resultclass=None, warnings=None, *, tb_locals=False)
|      Construct a TextTestRunner.
</code></pre><p>参数 verbosity：</p>
<pre><code>verbosity参数可以控制输出的错误报告的详细程度，只有3个取值：
0 (quiet): 只显示执行的用例的总数和全局的执行结果。
1 (default): 默认值，显示执行的用例的总数和全局的执行结果，并对每个用例的执行结果（成功T或失败F）有个标注。
2 (verbose): 显示执行的用例的总数和全局的执行结果，并输出每个用例的详细的执行结果。
</code></pre><p>9、 PyUnit 模块中定义了一个名为main 的全局方法，使用它可以很方便地将一个单元测试模块变成可<br>以直接运行的测试脚本，main()方法使用TestLoader 类来搜索所有包含在该模块中的测试方法，并自<br>动执行它们。如果Python 程序员能够按照约定（以test 开头）来命名所有的测试方法，那就只需要在<br>测试模块的最后加入如下几行代码即可:</p>
<pre><code>if __name__ == &apos;__main__&apos;:
        unittest.main()
</code></pre><p>10、 自动搜索指定目录下的case，构造测试集，执行顺序是命名顺序，（默认按ASCII码顺序加载测试用例），(pattern=’test_*.py’匹配test开头的所有脚本)</p>
<pre><code>test_dir = os.path.join(os.getcwd())
discover = unittest.defaultTestLoader.discover(test_dir, pattern=‘test_*.py’)
runner = unittest.TextTestRunner()
runner.run(discover)
</code></pre><p>相关链接：python接口自动化测试(七)-unittest-批量用例管理 - 贺满 - 博客园  <a href="https://www.cnblogs.com/puresoul/p/7490737.html" target="_blank" rel="noopener">https://www.cnblogs.com/puresoul/p/7490737.html</a></p>
<h1 id="批量执行测试用例"><a href="#批量执行测试用例" class="headerlink" title="批量执行测试用例"></a>批量执行测试用例</h1><p>通过对前面对unittest 框架的学习我们了解到，可以在一个.py 文件里编写多个测试用例，然后执行<br>文件里的所有用例，这显然是一个不错的做法，我们可以将一些相关的用例放到一个文件里，unittest 支持这么做，但假如我们成百上千的用例呢，放一.py 文件显然有些不太合理。<br>比较合理的做法是把相关的几条用例放到一个.py 文件里，把所有.py 文件放到一个文件夹下，然后通<br>过一个程序执行文件夹下面的所有用例。</p>
<p><img src="https://i.imgur.com/TzIuE0h.png" alt=""></p>
<p>编写baidu.py 文件放入test_case 文件夹下：</p>
<pre><code>    #coding=utf-8
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select
from selenium.common.exceptions import NoSuchElementException
from selenium.common.exceptions import NoAlertPresentException
import unittest, time, re

class Baidu(unittest.TestCase):
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.driver.implicitly_wait(30)
        self.base_url = &quot;https://www.baidu.com&quot;
        self.verificationErrors = []
        self.accept_next_alert = True

    def test_baidu_search(self):
        driver = self.driver
        driver.get(self.base_url + &quot;/&quot;)
        driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium webdriver&quot;)
        driver.find_element_by_id(&quot;su&quot;).click()
        time.sleep(2)
        driver.close()

    def test_baidu_set(self):
        driver = self.driver
        driver.get(self.base_url + &quot;/&quot;)

        driver.find_element_by_link_text(u&quot;设置&quot;).click()
        driver.find_element_by_link_text(u&quot;搜索设置&quot;).click()
        time.sleep(2)
        Select(driver.find_element_by_id(&quot;nr&quot;)).select_by_visible_text(u&quot;每页显示20条&quot;)
        time.sleep(2)

        driver.find_element_by_link_text(u&quot;保存设置&quot;).click()
        time.sleep(2)
        driver.switch_to_alert().accept()

    def tearDown(self):
        self.driver.quit()
        self.assertEqual([], self.verificationErrors)

if __name__ == &apos;__main__&apos;:
    unittest.main()
</code></pre><p>下面编写test_case.py 点文件来读取test_case 文件夹下的文件：</p>
<pre><code>    #coding=utf-8
import os

caselist = os.listdir(&quot;D:\\PythonTestFiles\\seleniumTest\\Unittest\\test_case&quot;)
for a in caselist:
    s = a.split(&apos;.&apos;)[1]
    if s == &quot;py&quot;:
        os.system(&quot;D:\\PythonTestFiles\\seleniumTest\\Unittest\\test_case\\%s 1&gt;&gt;log.txt 2&gt;&amp;1&quot;%a)
</code></pre><p>注：</p>
<pre><code>os.system（）执行命令，文件
os.system(cmd)的返回值只会有0(成功),1,2
区别于os.popen（）
os.popen(cmd)会吧执行的cmd的输出作为值返回。
1&gt;&gt;log.txt 将日志重定向到log.txt文件中
2&gt;&amp;1 ： 
    2 与 &gt; 结合，代表错误重定向，而1则代表错误重定向到一个文件，而不是代表标准输出；
    2&gt;&amp;1，&amp;与1结合，就代表标准输出了，就变成错误重定向到标准输出。
（1&gt;&gt;log.txt 2&gt;&amp;1） 整体结果就是：将日志存入log.txt文件。
</code></pre><h2 id="使用Select定位"><a href="#使用Select定位" class="headerlink" title="使用Select定位"></a>使用Select定位</h2><pre><code>Select(driver.find_element_by_id(&quot;nr&quot;)).select_by_visible_text(u&quot;每页显示20条&quot;)
</code></pre><blockquote>
<p>相关链接：selenium+Python(select定位) - Silence&amp;QH - 博客园  <a href="https://www.cnblogs.com/101718qiong/p/7929731.html" target="_blank" rel="noopener">https://www.cnblogs.com/101718qiong/p/7929731.html</a></p>
</blockquote>
<p>例：百度搜索设置显示条数：</p>
<pre><code>&lt;select name=&quot;NR&quot; id=&quot;nr&quot;&gt;
    &lt;option value=&quot;10&quot; selected=&quot;&quot;&gt;每页显示10条&lt;/option&gt;
    &lt;option value=&quot;20&quot;&gt;每页显示20条&lt;/option&gt;
    &lt;option value=&quot;50&quot;&gt;每页显示50条&lt;/option&gt;&lt;/select&gt;
</code></pre><p>导入Select方法：</p>
<pre><code>from selenium.webdriver.support.select import Select
</code></pre><p>Select对象：</p>
<pre><code>element  = driver.find_element_by_id(&quot;nr)
Select(element).select_by_index(2)
#Select(element).select_by_value(20)
#Select(element).select_by_visible_text(u&quot;每页显示20条&quot;)
</code></pre><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p><strong>二次定位</strong></p>
<p>基本思路，先定位 select 框，再定位 select 里的选项</p>
<p>可以有两种写法：第一种是分不够一步一步定位，第二种是直接一个语句定位两次，如例所示</p>
<p>Select定位有三种方式：</p>
<pre><code>select_by_index() :通过索引定位
select_by_value() :通过 value 值定位
select_by_visible_text() :通过文本值定位
</code></pre><p>除了上三种方法，还包括的功能：</p>
<pre><code>deselect_all() ：取消所有选项
deselect_by_index() ：取消对应 index 选项
deselect_by_value() ：取消对应 value 选项
deselect_by_visible_text() ：取消对应文本选项
first_selected_option() ：返回第一个选项
all_selected_options() ：返回所有的选项
</code></pre><h1 id="生成HTMl报告"><a href="#生成HTMl报告" class="headerlink" title="生成HTMl报告"></a>生成HTMl报告</h1><p>相关链接：python接口自动化测试(八)-unittest-生成测试报告 - 贺满 - 博客园  <a href="https://www.cnblogs.com/puresoul/p/7490881.html" target="_blank" rel="noopener">https://www.cnblogs.com/puresoul/p/7490881.html</a></p>
<h2 id="引入HTMLTestRunner"><a href="#引入HTMLTestRunner" class="headerlink" title="引入HTMLTestRunner"></a>引入HTMLTestRunner</h2><p>这个模块不能通过pip安装，需要下载后导入py文件到安装路径site-packages下</p>
<pre><code>查看安装路径： import sys
            sys.path
</code></pre><p>python3.x ：</p>
<p>HTMLTestRunner修改Python3的版本-猴子请来的救兵-51CTO博客  <a href="http://blog.51cto.com/hzqldjb/1590802" target="_blank" rel="noopener">http://blog.51cto.com/hzqldjb/1590802</a></p>
<p>修改后HTMLTestRunner下载地址：<a href="http://pan.baidu.com/s/1tp3Ts" target="_blank" rel="noopener">http://pan.baidu.com/s/1tp3Ts</a></p>
<p>使用生成报告例（只给出使用部分代码）：</p>
<pre><code>...        
import HTMLTestRunner
...
if __name__ == &apos;__main__&apos;:
    #定义一个测试容器
    test = unittest.TestSuite()

    #将测试用例，加入到测试容器中
    test.addTest(Baidu(&quot;test_baidu_search&quot;))

    #定义个报告存放的路径，支持相对路径
    file_path = &quot;D:\\PythonTestFiles\\seleniumTest\\Unittest\\result.html&quot;
    file_result = open(file_path, &quot;wb&quot;)

    #定义测试报告
    runner = HTMLTestRunner.HTMLTestRunner(stream=file_result, title=u&quot;Search Report for Baidu&quot;,description=u&quot;Test Case exec Situation&quot;)

    #运行测试用例
    runner.run(test)
    file_result.close()
</code></pre><p>定义HTMLTestRunner 测试报告，stream 定义报告所写入的文件；title 为报告的标题；<br>description 为报告的说明与描述。（verbosity同TextTestRunner）</p>
<p>注：对比 TextTestRunner</p>
<p>运行生成后报告如下：</p>
<p><img src="https://i.imgur.com/I5Czt3N.png" alt=""></p>
<p>参考链接： Python3 unittest单元测试 - 毛斯钢 - 博客园  <a href="https://www.cnblogs.com/znyyy/p/8086281.html" target="_blank" rel="noopener">https://www.cnblogs.com/znyyy/p/8086281.html</a></p>
<p>Python3 Selenium自动化web测试 ==&gt; 第一节 起始点之Python单元测试框架 unittest - 脚本_驱动_测试 - 博客园  <a href="https://www.cnblogs.com/wuzhiming/p/8858305.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuzhiming/p/8858305.html</a></p>
<p>unittest详解（二） 跳过用例的执行(skip) - eastonliu - 博客园  <a href="https://www.cnblogs.com/eastonliu/p/9145231.html" target="_blank" rel="noopener">https://www.cnblogs.com/eastonliu/p/9145231.html</a></p>
<h1 id="忽略某个测试用例不执行，也就是跳过某个用例不执行"><a href="#忽略某个测试用例不执行，也就是跳过某个用例不执行" class="headerlink" title="忽略某个测试用例不执行，也就是跳过某个用例不执行"></a>忽略某个测试用例不执行，也就是跳过某个用例不执行</h1><pre><code>import unittest
import sys

class TestStringMethods(unittest.TestCase):
    @unittest.skipIf(&apos;F&apos;==&apos;f&apos;,&apos;Execute if the judgement condition is not satisfied&apos;)
    def test_upper2(self):
        self.assertEqual(&apos;foo&apos;.upper(), &apos;FOO&apos;)
        print(&apos;test_upper2&apos;)

    @unittest.skipIf(&apos;F&apos;==&apos;f&apos;.upper(), &apos;If the condition is satisfited,it will not executed&apos;)
    def test_upper(self):
        self.assertEqual(&apos;foo&apos;.upper(), &apos;FOO&apos;)
        print(&apos;test_upper&apos;)

    @unittest.skip(&apos;Ignore this test case and do not execute&apos;)
    def test_isupper(self):
        self.assertTrue(&apos;FOO&apos;.isupper())
        self.assertFalse(&apos;Foo&apos;.isupper())
        print(&apos;test_isupper&apos;)

    @unittest.skipUnless(sys.platform.startswith(&apos;Linux&apos;), &apos;we need window&apos;)
    def test_split(self):
        s = &apos;hello world&apos;
        self.assertEqual(s.split(), [&apos;hello&apos;, &apos;world&apos;])
        with self.assertRaises(TypeError):
            s.split(2)
        print(&apos;test_split&apos;)

if __name__ == &apos;__main__&apos;:
    suite1 = unittest.TestSuite()
    suite1.addTests([TestStringMethods(&apos;test_upper2&apos;),TestStringMethods(&apos;test_split&apos;),TestStringMethods(&apos;test_isupper&apos;),TestStringMethods(&apos;test_upper&apos;)])
    runner2 = unittest.TextTestRunner(verbosity=2)
    runner2.run(suite1)
</code></pre><p>执行结果：</p>
<pre><code>&gt;&gt;&gt; 
test_upper2 (__main__.TestStringMethods) ... test_upper2
ok
test_split (__main__.TestStringMethods) ... skipped &apos;we need window&apos;
test_isupper (__main__.TestStringMethods) ... skipped &apos;Ignore this test case and do not execute&apos;
test_upper (__main__.TestStringMethods) ... skipped &apos;If the condition is satisfited,it will not executed&apos;

----------------------------------------------------------------------
Ran 4 tests in 0.508s

OK (skipped=3)
</code></pre><p>unittest提供的跳过一些用例的方法：</p>
<pre><code>@unittest.skip(reason)：强制跳转。reason是跳转原因
@unittest.skipIf(condition, reason)：condition为True的时候跳转
@unittest.skipUnless(condition, reason)：condition为False的@unittest.expectedFailure：如果test失败了，这个test不计入失败的case数目时候跳转
</code></pre><p>相关其他的实例：unittest详解（二） 跳过用例的执行(skip) - eastonliu - 博客园  <a href="https://www.cnblogs.com/eastonliu/p/9145231.html" target="_blank" rel="noopener">https://www.cnblogs.com/eastonliu/p/9145231.html</a></p>
<h2 id="将运行结果保存到文件中"><a href="#将运行结果保存到文件中" class="headerlink" title="将运行结果保存到文件中"></a>将运行结果保存到文件中</h2><pre><code>if __name__ == &apos;__main__&apos;:
suite1 = unittest.TestSuite()
suite1.addTests([TestStringMethods(&apos;test_upper2&apos;),TestStringMethods(&apos;test_split&apos;),TestStringMethods(&apos;test_isupper&apos;),TestStringMethods(&apos;test_upper&apos;)])
#runner2 = unittest.TextTestRunner(verbosity=2)
#runner2.run(suite1)

with open(&apos;result.txt&apos;, &apos;a+&apos;, encoding=&apos;utf-8&apos;) as f:
    runner2 = unittest.TextTestRunner(stream=f, verbosity=2)
    runner2.run(suite1)
</code></pre><p>输出：<br>    &gt;&gt;&gt;<br>    test_upper2<br>    &gt;&gt;&gt;</p>
<h2 id="报告文件名取当前时间"><a href="#报告文件名取当前时间" class="headerlink" title="报告文件名取当前时间"></a>报告文件名取当前时间</h2><p>每次运行测试之前之前都要手动的去修改报告的名称，如果有修改就会把之前的报告覆盖，这样做就<br>会显示得很麻烦，那么有没有办法使每次生成的报告名称都不一样，为了更好的取分报告可以在报告中添<br>加当前的时间，这样我们要想查找某天某时所生成的报告就会变得非常容易。</p>
<p><strong>time.time()</strong> 获取当前时间戳</p>
<p><strong>time.localtime()</strong> 当前时间的struct_time 形式</p>
<p><strong>time.ctime()</strong> 当前时间的字符串形式</p>
<p><strong>time.strftime(“%Y-%m-%d %H:%M:%S”, time.localtime())</strong></p>
<p>实例：</p>
<pre><code>&gt;&gt;&gt; import time
&gt;&gt;&gt; time.time()
    1542964210.3512118
&gt;&gt;&gt; time.ctime()
    &apos;Fri Nov 23 17:10:17 2018&apos;
&gt;&gt;&gt; time.localtime()
    time.struct_time(tm_year=2018, tm_mon=11, tm_mday=23, tm_hour=17, tm_min=10, tm_sec=36, tm_wday=4, tm_yday=327, tm_isdst=0)
&gt;&gt;&gt; time.strftime(&quot;%Y%m%d%H%M%S&quot;, time.localtime())
    &apos;20181123171129&apos;
&gt;&gt;&gt; time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())
    &apos;2018-11-23 17:12:16&apos;
</code></pre><p>引入测试文件：</p>
<pre><code>...
import time
...
now = time.strftime(&quot;%Y-%m-%d-%H_%M_%S&quot;, time.localtime(time.time()))

filename = &apos;D:\\PythonTestFiles\\seleniumTest\\Unittest\\report\\&apos;+now+&apos;result.html&apos;
fp = open(filename, &apos;wb&apos;)

runner1 = HTMLTestRunner(stream=fp, title=u&apos;Test Result(Baidu,Youdao)&apos;, description=u&apos;Situation of Test Case&apos;)
runner1.run(testunit)

fp.close()
</code></pre><p>执行后生成报告文件名称如图：<br><img src="https://i.imgur.com/76DHzWX.png" alt=""></p>
<pre><code>__init__.py文件解析
要弄明白这个问题，首先要知道，python 在执行import 语句时，到底进行了什么操作，按照python 的文档，它执行了如下操作：    
第1 步，创建一个新的，空的module 对象（它可能包含多个module）；
第2 步，把这个 module 对象插入sys.module 中
第3 步，装载 module 的代码（如果需要，首先必须编译）
第4 步，执行新的module 中对应的代码。
在执行第3 步时，首先要找到module 程序所在的位置，搜索的顺序是：
    当前路径（以及从当前目录指定的sys.path），然后是PYTHONPATH，然后是python 的安装设置相关的默认路径。正因为存在这样的顺序，如果当前路径或PYTHONPATH 中存在与标准module 同样的module，则会覆盖标准module。也就是说，如果当前目录下存在xml.py，那么执行import xml 时，导入的是当前目录下的module，而不是系统标准的xml。
了解了这些，我们就可以先构建一个package，以普通module 的方式导入，就可以直接访问此package中的各个module 了。python 中的package 必须包含一个__init__.py 的文件。

为了标识一下目录是可引用的包，那么就需要在目录下创建一个__init__.py 文件。
其实__init__.py 文件中可以有内容；我们在导入一个包时，实际上导入了它的__init__.py 文件。
在__init__.py 文件中添加导入包。

import baidu
import youdao

在all_tests.py中只需加入路径，导入全部包:
import sys
sys.path.append(&apos;\test_case&apos;)
from test_case import *

注：
在我的python3环境下，sys.path只添加到相对路径后，在PyScripter中执行后在__init__.py执行时仍会报错：
...
Error： File &quot;D:\PythonTestFiles\seleniumTest\Unittest\test_case\__init__.py&quot;, line 1, in &lt;module&gt;
import baidu
ModuleNotFoundError: No module named &apos;baidu&apos;
解决办法是，sys.path.append时加入绝对路径：
sys.path.append(&apos;D:\\PythonTestFiles\\seleniumTest\\Unittest\\test_case&apos;),则解决问题。

all_tests.py完整代码：

import unittest
from HTMLTestRunner import HTMLTestRunner
import time

import sys
sys.path.append(&apos;D:\\PythonTestFiles\\seleniumTest\\Unittest\\test_case&apos;)
#print(sys.path )
from test_case import *

testunit = unittest.TestSuite()

testunit.addTest(unittest.makeSuite(baidu.Baidu))
testunit.addTest(unittest.makeSuite(youdao.Youdao))

#runner = unittest.TextTestRunner()
#runner.run(testunit)

now = time.strftime(&quot;%Y-%m-%d-%H_%M_%S&quot;, time.localtime(time.time()))

filename = &apos;D:\\PythonTestFiles\\seleniumTest\\Unittest\\report\\&apos;+now+&apos;result.html&apos;
fp = open(filename, &apos;wb&apos;)

runner1 = HTMLTestRunner(stream=fp, title=u&apos;Test Result(Baidu,Youdao)&apos;, description=u&apos;Situation of Test Case&apos;)
runner1.run(testunit)

fp.close()
</code></pre><h3 id="discover解决用例的读取"><a href="#discover解决用例的读取" class="headerlink" title="discover解决用例的读取"></a>discover解决用例的读取</h3><p>unittest 的TestLoader 成员下面提供了discover()方法可解决用例文件自动添加到测试套件中。通过文件的名称来判断是否为测试用例文件。</p>
<pre><code>TestLoader：测试用例加载器，其包括多个加载测试用例的方法。返回一个测试套件。

discover(start_dir，pattern=&apos;test*.py&apos;，top_level_dir=None)
找到指定目录下所有测试模块，并可递归查到子目录下的测试模块，只有匹配到文件名才能被加载。
如果启动的不是顶层目录，那么顶层目录必须要单独指定。

start_dir ：要测试的模块名或测试用例目录。
pattern=&apos;test*.py&apos; ：表示用例文件名的匹配原则。星号“*”表示任意多个字符。

这里需要说明一个测试用例的创建规则：我们在实际的测试用开发中用例的创建也应该分两个阶段，
用例刚在目录下被创建，可命名为aa.py ，当用例创建完成并且运行稳定后再添加到测试套件中。那么可以将aa.py 重新命名为start_aa.py ，那么测试套件在运行时只识别并运行start 开头的.py 文件。

理解了这个规则，我们就可以按照一个约定来命名自己用例文件名。这里我们将baidu.py 、youdao.py和webcoud.py 三个文件重命名为以start_开头。

top_level_dir=None：测试模块的顶层目录。如果没顶层目录（也就是说测试用例不是放在多级目录中），默认为None。
</code></pre><p>最后的整个包结构：<br><img src="https://i.imgur.com/zexr43W.png" alt=""></p>
<p>test_case 目录用于存具体的用例，/test_case/public 目录存入测试用例所调用的公共模块；data<br>目录用于存放参数化的数据；report 目录用于存放测试报告，，all_case.py 文件执行test_case目录中的测试用例</p>
<h3 id="获取最新的report文件"><a href="#获取最新的report文件" class="headerlink" title="获取最新的report文件"></a>获取最新的report文件</h3><p>如，report存按时间生成的report.html，可以设置获取最新的report。</p>
<pre><code>import os, datetime, time

result_dir = &apos;D:\\PythonTestFiles\\seleniumTest\\Unittest\\report&apos;

lists = os.listdir(result_dir)
lists.sort(key=lambda fn: os.path.getmtime(result_dir+&quot;\\&quot;+fn) if not
            os.path.isdir(result_dir+&quot;\\&quot;+fn) else 0)

print(&apos;newest file is: &apos; + lists[-1])
file = os.path.join(result_dir, lists[-1])
print(file)
</code></pre><p>解析：</p>
<p><strong>os.listdir()</strong></p>
<p>用于获取目录下的所有文件列表</p>
<p><strong>lists.sort(key=lambda fn: os.path.getmtime(result_dir+”\“+fn) if not os.path.isdir(result_dir+”\“+fn) else 0)</strong></p>
<p>在这段代码中，这一条语句是比较复杂难懂的，我们将其拆开来分析。</p>
<pre><code>lists.sort()
Python 列表有一个内置的列表。sort()方法用于改变列表中元素的位置。还有一个sorted()内置函数，建立了一种新的迭代排序列表。

总结： sorted 和list.sort 都接受key, reverse定制。但是区别是。list.sort()是列表中的方法，只能用于列表。而sorted可以用于任何可迭代的对象。list.sort()是在原序列上进行修改，不会产生新的序列。所以如果你不需要旧的序列，可以选择list.sort()。 sorted() 会返回一个新的序列。旧的对象依然存在。

key=lambda fn:
key 是带一个参数的函数，用来为每个元素提取比较值. 默认为None, 即直接比较每个元素
lambda 提供了一个运行时动态创建函数的方法。我这里创建了fn 函数。

下面一个小例子来演示通过sort()方法对一数组进排序：
    #定位一个数组
&gt;&gt;&gt; lists=[&apos;c.txt&apos;,&apos;b.txt&apos;,&apos;d.txt&apos;,&apos;a.txt&apos;]
&gt;&gt;&gt; lists
[&apos;c.txt&apos;, &apos;b.txt&apos;, &apos;d.txt&apos;, &apos;a.txt&apos;]
    #取数组中的key 做排序
&gt;&gt;&gt; lists.sort(key=lambda ls:ls[0])
&gt;&gt;&gt; print lists
[&apos;a.txt&apos;, &apos;b.txt&apos;, &apos;c.txt&apos;, &apos;d.txt&apos;]
&gt;&gt;&gt; lists.sort(key=lambda ls:ls[1])
&gt;&gt;&gt; lists
[&apos;c.txt&apos;, &apos;b.txt&apos;, &apos;d.txt&apos;, &apos;a.txt&apos;]
lists:lists[0] 表示取的是每个元组中的前半部分，即为：c、b、d、a ，所以可进行排序。
lists:lists[1] 表示取的是每个元组中的后半部分，即为：txt ，不能有效的进行排序规律，所以按照数组的原样输出。
</code></pre><p><strong>os.path.getmtime()</strong></p>
<p>getmtime()返回文件列表中最新文件的时间（最新文件的时间最大，所以我们会得到一个最大时间）</p>
<p><strong>os.path.isdir()</strong></p>
<p>isdir()函数判断某一路径是否为目录。</p>
<p>经过sort()复杂的运算，我们获得了最新的lists 文件列表，这个文件列表是根据文件的创建时间进行<br>排序的。</p>
<p><strong>lists[-1]</strong></p>
<p>-1 表示取文件列表中的最大值，也就是最新被创建的文件。</p>
<p><strong>os.path.join()</strong></p>
<p>join()方法用来连接字符串，通过路径与文件名的拼接，我们将得到目录下最新被创建的的文件名的完<br>整路径。</p>
<p>运行newfile.py 得到如下结果：</p>
<pre><code>&gt;&gt;&gt; 
newest file is: 2018-11-26-11_37_26result.html
D:\PythonTestFiles\seleniumTest\Unittest\repor\2018-11-26-11_37_26result.html
</code></pre><p>#多进程/多线程 #</p>
<h2 id="threading-模块"><a href="#threading-模块" class="headerlink" title="threading 模块"></a>threading 模块</h2><p>threading模块支持守护进程（python3以上已没有thread模块）</p>
<p>例：</p>
<pre><code>import threading
from time import sleep, ctime

loops = [4, 2]

def loop(nloop, nsec):
    print(&apos;start loop&apos;, nloop, &apos;at:&apos;, ctime())
    sleep(nsec)
    print(&apos;loop&apos;, nloop, &apos;done at:&apos;, ctime())

def main():
    print(&apos;starting at:&apos;, ctime())
    threads = []
    nloops = range(len(loops))

    #create threads
    for i in nloops:
        t = threading.Thread(target=loop, args=(i, loops[i]))
        threads.append(t)

    #start threads
    for i in nloops:
        threads[i].start()

    #wait for ends of all threads
    for i in nloops:
        threads[i].join()

    print(&apos;all end:&apos;, ctime())

if __name__ == &apos;__main__&apos;:
    main()
</code></pre><p><strong>start()</strong></p>
<p>可是线程活动</p>
<p><strong>join()</strong></p>
<p>等待线程的终止</p>
<p>所有的线程都创建了之后，再一起调用start()函数启动，而不是创建一个启动一个。而且，不用再管理一堆锁（分配锁，获得锁，释放锁，检查锁的状态等），只要简单地对每个线程调用join()函数就可以了。</p>
<p>join()会等到线程结束，或者在给了timeout参数的时候，等到超时为止。join()的另一个比较重要的方面是它可以完成不用调用。一旦线程启动后，就会一直运行，直到线程的函数结束，退出为止。</p>
<p>使用可调用的类：</p>
<pre><code>import threading
from time import sleep, ctime

loops = [4, 2]

class ThreadFunc(object):
    def __init__(self,func,args,name=&apos;&apos;):
        self.name = name
        self.func = func
        self.args = args

    def __call__(self):
        #apply(self.func, self.args)  #in python3,apply() not exists
        self.func(*self.args)

def loop(nloop, nsec):
    print(&apos;start loop&apos;, nloop, &apos;at:&apos;, ctime())
    sleep(nsec)
    print(&apos;loop&apos;, nloop, &apos;done at&apos;, ctime())

def main():
    print(&apos;starting at:&apos;, ctime())
    threads = []
    nloops = range(len(loops))

    for i in nloops:
        t = threading.Thread(
                target=ThreadFunc(loop, (i,loops[i]), loop.__name__))
        threads.append(t)

    for i in nloops:
        threads[i].start()

    for i in nloops:
        threads[i].join()

    print(&apos;all end:&apos;, ctime())

if __name__ == &apos;__main__&apos;:
    main()
</code></pre><blockquote>
<pre><code>**APPLY()**

python2有一个叫做apply()的全局函数，它使用一个函数f和一个列表[a,b,c]作为参数，返回值是f(a,b,c).可以直接调用这个函数，在列表前添加一个星号作为参数传递给它来完成同样的事情。在python3里，apply()函数不再存在；必须使用星号标记。

![](https://i.imgur.com/GL3KcSE.png)

(相关链接：http://cache.baiducontent.com/c?m=9d78d513d9810ae902b0c8690c66d6711925d3217e899b013894cd47c9221d030671e2c83a3f554196d27c1050f31902b7a57765377471eac4d5cd1d86e2d57467c03a766d188c4617d81cacdc46529b66cf04&amp;p=882a9645dcd218e709be9b7c4f4c93&amp;newp=917fc91d85cc43be03bd9b7d0d1cc9231610db2151d4d5116b82c825d7331b001c3bbfb423261000d3ce7c6201a94a5be8f732763d0923a3dda5c91d9fb4c57479997c&amp;user=baidu&amp;fm=sc&amp;query=python3+apply&amp;qid=975390f700007b4d&amp;p1=1)
</code></pre></blockquote>
<p>创建新线程的时候，Thread 对象会调用我们的ThreadFunc 对象，这时会用到一个特殊函数<strong>call</strong>()。由于我们已经有了要用的参数，所以就不用再传到Thread()的构造函数中。由于我们有一个参数的元组，这时要在代码中使用apply()函数。</p>
<p>我们传了一个可调用的类(的实例)，而不是仅传一个函数</p>
<p><strong><strong>init</strong>()</strong></p>
<p>方法在类的一个对象被建立时运行。这个方法可以用来对你的对象做一些初始化</p>
<p><strong>apply()</strong></p>
<p>apply(func [, args [, kwargs ]]) 函数用于当函数参数已经存在于一个元组或字典中时，间接地调用函数。args 是一个包含将要提供给函数的按位置传递的参数的元组。如果省略了args，任何参数都不会被传递，kwargs 是一个包含关键字参数的字典。</p>
<h2 id="multiprocessing-模块"><a href="#multiprocessing-模块" class="headerlink" title="multiprocessing 模块"></a>multiprocessing 模块</h2><p>multiprocessing 使用类似于threading 模块的API ，multiprocessing 提供了本地和远程的并发性，有效的通过全局解释锁(Global Interceptor Lock, GIL)来使用进程(而不是线程)。由于GIL 的存在，在CPU 密集型的程序当中，使用多线程并不能有效地利用多核CPU 的优势，因为一个解释器在同一时刻只会有一个线程在执行。所以，multiprocessing 模块可以充分的利用硬件的多处理器来进行工作。它支持Unix 和Windows 系统上的运行。</p>
<pre><code>from multiprocessing import Process

def f(name):
    print(&apos;hello&apos;, name)

if __name__ == &apos;__main__&apos;:
    p = Process(target=f, args=(&apos;bob&apos;,))
    p.start()
    p.join()
运行结果：
hello bob
</code></pre><p>与threading.Thread 类似，它可以利用multiprocessing.Process 对象来创建一个进程。</p>
<p>Process 对象与Thread 对象的用法相同，也有start(), run(), join()的方法。</p>
<pre><code>multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={})
</code></pre><p>target 表示调用对象，args 表示调用对象的位置参数元组。kwargs 表示调用对象的字典。Name 为别名。group 实质上不使用。</p>
<p>扩展理解：</p>
<pre><code>在*nix 上面创建的新的进程使用的是fork：
一个进程，包括代码、数据和分配给进程的资源。fork()函数通过系统调用创建一个与原来进程几乎
完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程
也可以做不同的事。
这意味着子进程开始执行的时候具有与父进程相同的全部内容。请记住这点，这个将是下面我们讨论
基于继承的对象共享的基础。所谓基于继承的对象共享，是说在创建子进程之前由父进程初始化的某些对
象可以在子进程当中直接访问到。在Windows 平台上，因为没有fork 语义的系统调用，基于继承的共
享对象比*nix 有更多的限制，最主要就是体现在要求Process 的__init__当中的参数必须可以Pickle。
但是，并不是所有的对象都是可以通过继承来共享，只有multiprocessing 库当中的某些对象才可以。
例如Queue，同步对象，共享变量，Manager 等等。
在一个multiprocessing 库的典型使用场景下，所有的子进程都是由一个父进程启动起来的，这个父
进程称为master 进程。这个父进程非常重要，它会管理一系列的对象状态，一旦这个进程退出，子进程
很可能会处于一个很不稳定的状态，因为它们共享的状态也许已经被损坏掉了。因此，这个进程最好尽可
能做最少的事情，以便保持其稳定性。
</code></pre><p><strong>获取进程ID</strong></p>
<p>process2.py</p>
<pre><code>from multiprocessing import Process
import os

def info(title):
    print(title)
    print(&apos;module name:&apos;, __name__)
    if hasattr(os, &apos;getppid&apos;):
        print(&apos;parent process:&apos;, os.getppid())
    print(&apos;process id:&apos;, os.getpid())

def f(name):
    info(&apos;function f&apos;)
    print(&apos;hello&apos;, name)

if __name__ == &apos;__main__&apos;:
    info(&apos;main line&apos;)
    p = Process(target=f, args=(&apos;bob&apos;,))
    p.start()
    p.join()

运行结果：
&gt;&gt;&gt; 
main line
module name: __main__
parent process: 7940
process id: 2416
function f
module name: __mp_main__
parent process: 2416
process id: 7888
hello bob
</code></pre><p>multiprocessing 提供了threading 包中没有的IPC(比如Pipe 和Queue)，效率上更高。应优先<br>考虑Pipe 和Queue，避免使用Lock/Event/Semaphore/Condition 等同步方式(因为它们占据的不<br>是用户进程的资源)。</p>
<p><strong>hasattr(object, name)</strong></p>
<p>判断对象object 是否包含名为name 的特性（hasattr 是通过调用getattr(object, name)是否抛出异常来实现的）。hasattr(os, ‘getppid’) 用于判断系统是否包含getppid。</p>
<p>getpid()得到本身进程id，getppid()得到父进程进程id，如果已经是父进程，得到系统进程<br>id。</p>
<p>Process.PID 中保存有PID，如果进程还没有start()，则PID 为None。</p>
<h2 id="Pipe和queue"><a href="#Pipe和queue" class="headerlink" title="Pipe和queue"></a>Pipe和queue</h2><p>multiprocessing 包中有Pipe 类和Queue 类来分别支持这两种IPC 机制。Pipe 和Queue 可以<br>用来传送常见的对象。</p>
<p>（ 1 ） Pipe 可以是单向(half-duplex) ， 也可以是双向(duplex) 。我们通过<br>mutiprocessing.Pipe(duplex=False)创建单向管道(默认为双向)。一个进程从PIPE 一端输入<br>对象，然后被PIPE 另一端的进程接收，单向管道只允许管道一端的进程输入，而双向管道则允许从两端<br>输入。</p>
<p>pipe.py</p>
<pre><code>import multiprocessing

def procl(pipe):
    pipe.send(&apos;hello&apos;)
    print(&apos;procl rec:&apos;, pipe.recv())

def proc2(pipe):
    print(&apos;proc2 rec:&apos;, pipe.recv())
    pipe.send(&apos;hello, too&apos;)

pipe = multiprocessing.Pipe()

p1 = multiprocessing.Process(target=proc1, args=(pipe[0], ))
p2 = multiprocessing.Process(target=proc2, args=(pipe[1], ))

p1.start()
p2.start()
p1.join()
p2.join()
</code></pre><p><strong>注：本程序只能在Linux/Unix运行</strong></p>
<p>运行结果：</p>
<pre><code>‘proc2 rec:’，‘hello’
‘proc2 rec:’，‘hello,too’
</code></pre><p>这里的Pipe 是双向的。Pipe 对象建立的时候，返回一个含有两个元素的表，每个元素代表Pipe<br>的一端(Connection 对象)。我们对Pipe 的某一端调用send()方法来传送对象，在另一端使用recv()<br>来接收。</p>
<p>（2） Queue 与Pipe 相类似，都是先进先出的结构。但Queue 允许多个进程放入，多个进程从队<br>列取出对象。Queue 使用mutiprocessing.Queue(maxsize)创建，maxsize 表示队列中可以存放对<br>象的最大数量。</p>
<p>queue.py</p>
<pre><code>import os
import multiprocessing
import time

#input worker
def inputQ(queue):
    info = str(os.getpid()) + &apos;(put):&apos; + str(time.time())
    queue.put(info)

#output worker
def outputQ(queue, lock):
    info =queue.get()
    lock.acquire()
    print(str(os.getpid()) + &apos;(get):&apos; + info)
    lock.release()

#Main
record1 = []        #store input process
record2 = []        #store output process
lock = multiprocessing.lock()
queue = multiprocessing.Queue(3)

#input processes
for i in range(10):
    process = multiprocessing.Process(target=inputQ, args=(queue,))
    process.start()
    record1.append(process)

#output process
for i in range(10):
    process = multiprocessing.Process(target=outputQ, args=(queue,lock))
    process.start()
    record2.append(process)

for p in record1:
    p.join()

queue.close()

for p in record2:
    p.join()
</code></pre><p><strong>注：本程序只能在Linux/Unix运行</strong></p>
<p>运行结果：</p>
<pre><code>2702(get):2689(put):1387947815.56
2704(get):2691(put):1387947815.58
2706(get):2690(put):1387947815.56
2707(get):2694(put):1387947815.59
2708(get):2692(put):1387947815.61
2709(get):2697(put):1387947815.6
2703(get):2698(put):1387947815.61
2713(get):2701(put):1387947815.65
2716(get):2699(put):1387947815.63
2717(get):2700(put):1387947815.62
</code></pre><h1 id="多进程执行测试用例"><a href="#多进程执行测试用例" class="headerlink" title="多进程执行测试用例"></a>多进程执行测试用例</h1><p>因为多进程与多线程特性在python 中当中也属于比较高级的应用，对于初学者来说比理解起来有一定<br>难度，所以在介绍python 的多进程与多线程时我们通过相当的篇幅和实例来进行讲解，目的是为了让读<br>者深入的理解python 的多进程与多线程。</p>
<p>对文件结构调整：</p>
<p><img src="https://i.imgur.com/S4qkE1W.png" alt=""></p>
<p>编写 all_tests_process</p>
<p>（注：python3中已弃掉commands，改用subprocess）</p>
<pre><code>import unittest, time, os, multiprocessing
#import commands
import subprocess
from email.mime.text import MIMEText
import HTMLTestRunner
import sys
sys.path.append(&apos;\selenium_process&apos;)

def EEEcreatsuite1():
    casedir = []
    listaa = os.listdir(&quot;D:\\PythonTestFiles\\seleniumTest\\selenium_process&quot;)
    for xx in listaa:
        if &quot;thread&quot; in xx:
            casedir.append(xx)
    #print(casedir)

    suite = []
    for n in casedir:
        testunit = unittest.TestSuite()
        discover = unittest.defaultTestLoader.discover(str(n),
                    pattern=&apos;start_*.py&apos;,
                    top_level_dir=r&apos;D:\\&apos;)
        for test_suite in discover:
            for test_case in test_suite:
                testunit.addTests(test_case)
                #print(testunit)
        suite.append(testunit)
    return suite, casedir

def EEEmultiRunCase(suite,casedir):
    now = time.strftime(&apos;%Y-%m-%d-%H_%M_%S&apos;, time.localtime(time.time()))
    filename = &apos;D:\\PythonTestFiles\\seleniumTest\\selenium_process\\report&apos;+now+&apos;result.html&apos;
    fp = open(filename, &apos;wb&apos;)

    proclist = []
    s = 0
    for i in suite:
        runner = HTMLTestRunner.HTMLTestRunner(
                stream=fp,
                title=str(casedir[s]+u&apos;Test Report&apos;),
                description=u&apos;Test Case Running Situation:&apos;
                )

    proc = multiprocessing.Process(target=runner.run, args=(i,))
    proclist.append(proc)
    s = s + 1
    for proc in proclist:
        proc.start()
    for proc in proclist:
        proc.join()
    fp.close()

if __name__ == &apos;__main__&apos;:
    runtmp = EEEcreatsuite1()
    EEEmultiRunCase(runtmp[0],runtmp[1])
</code></pre><p><a href="https://www.cnblogs.com/zhming26/p/6283361.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhming26/p/6283361.html</a></p>
<p><a href="http://www.cnblogs.com/busui/p/7283137.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">http://www.cnblogs.com/busui/p/7283137.html?utm_source=itdadao&amp;utm_medium=referral</a></p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/10/25/Fiddler工具使用介绍（持续。。。）/" data-toggle="tooltip" data-placement="top"
                           title="Fiddler 工具使用记录(持续记录)">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/10/23/Github Pages和Hexo简明教程/" data-toggle="tooltip" data-placement="top"
                           title="Github Pages和Hexo简明教程">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#selenium-IDE"><span class="toc-text">selenium IDE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#selenium-IDE的安装-及介绍"><span class="toc-text">selenium IDE的安装 及介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Selenium-IDE-脚本录制"><span class="toc-text">Selenium IDE 脚本录制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#引入-unittest-框架"><span class="toc-text">引入 unittest 框架</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unittest-单元测试框架解析"><span class="toc-text">Unittest 单元测试框架解析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#批量执行测试用例"><span class="toc-text">批量执行测试用例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Select定位"><span class="toc-text">使用Select定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定位"><span class="toc-text">定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#生成HTMl报告"><span class="toc-text">生成HTMl报告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#引入HTMLTestRunner"><span class="toc-text">引入HTMLTestRunner</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#忽略某个测试用例不执行，也就是跳过某个用例不执行"><span class="toc-text">忽略某个测试用例不执行，也就是跳过某个用例不执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#将运行结果保存到文件中"><span class="toc-text">将运行结果保存到文件中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#报告文件名取当前时间"><span class="toc-text">报告文件名取当前时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#discover解决用例的读取"><span class="toc-text">discover解决用例的读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取最新的report文件"><span class="toc-text">获取最新的report文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threading-模块"><span class="toc-text">threading 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multiprocessing-模块"><span class="toc-text">multiprocessing 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipe和queue"><span class="toc-text">Pipe和queue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多进程执行测试用例"><span class="toc-text">多进程执行测试用例</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Baobiy 2019
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="">
</body>

</html>
